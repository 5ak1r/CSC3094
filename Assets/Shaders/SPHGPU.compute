#pragma kernel CalculateProperties
#pragma kernel CalculateForces
#pragma kernel MoveParticles

struct ParticleGPU
{
    float pressure;
    float density;

    float3 forces;
    float3 velocity;
    float3 position;
};

// general settings
int particleCount;
float3 boxDimensions;

float epsilon;
float deltaTime;

// fluid settings
float particleMass;
float restDensity;
float gasConstant;
float viscosity;

// particle settings
float smoothingRadius;
float smoothingRadius2;

// kernel settings
float polyMult; // 315 / (64*pi*smoothingRadius3)
float spikyGradMult; // -45 / (pi*smoothingRadius3)
float viscLapMult; // 45 / (pi*smoothingRadius5)

RWStructuredBuffer<ParticleGPU> _particles;

// kernels
// https://rlguy.com/sphfluidsim/
inline float Poly6(in float distance2)
{
    float x = 1 - distance2 / smoothingRadius2;
    return polyMult * x * x * x;
}

inline float3 SpikyGradient(in float distance, in float3 direction)
{
    float x = 1 - distance / smoothingRadius;
    return spikyGradMult * x * x * direction;
}

// https://matthias-research.github.io/pages/publications/sca03.pdf
inline float ViscosityLaplacian(in float distance)
{
    float x = 1 - distance / smoothingRadius;
    return viscLapMult * x;
}

[numthreads(256,1,1)]
void CalculateProperties(int id: SV_DISPATCHTHREADID)
{
    float density = 0;

    for (int i = 0; i < particleCount; i++)
    {
        float3 offset = _particles[id.x].position - _particles[i].position;
        float distance2 = dot(offset, offset);

        if (distance2 < smoothingRadius2)
        {
            density += Poly6(distance2) * particleMass;
        }
    }

    _particles[id.x].density = density + epsilon;
    _particles[id.x].pressure = max(0, gasConstant * (_particles[id.x].density - restDensity));
}

[numthreads(256,1,1)]
void CalculateForces(int id: SV_DISPATCHTHREADID)
{
    float3 gravityForce = float3(0, -9.81, 0) * particleMass;
    float3 pressureForce = float3(0,0,0);
    float3 viscosityForce = float3(0,0,0);

    for (int i = 0; i < particleCount; i++)
    {
        if (id.x == i) continue;

        float3 offset = _particles[id.x].position - _particles[i].position;
        float distance2 = dot(offset, offset);

        if (distance2 < smoothingRadius2)
        {   
            float distance = sqrt(distance2);
            pressureForce -= particleMass * (_particles[id.x].pressure + _particles[i].pressure) / (2 * _particles[i].density) * SpikyGradient(distance, normalize(offset));
            viscosityForce += particleMass * (_particles[i].velocity - _particles[id.x].velocity) / _particles[i].density * ViscosityLaplacian(distance);
        }
    }

    _particles[id.x].forces = gravityForce + pressureForce + viscosityForce;
}

[numthreads(256,1,1)]
void MoveParticles(int id: SV_DISPATCHTHREADID)
{
    float damping = -0.3;

    float3 vel = _particles[id.x].velocity + deltaTime * _particles[id.x].forces / particleMass; //v = u + at, F = ma
    float3 pos = _particles[id.x].position + vel * deltaTime;

    if (pos.x - smoothingRadius < 0) 
    {
        pos.x = smoothingRadius;
        vel.x *= damping;
    }
    else if (pos.x + smoothingRadius > boxDimensions.x)
    {
        pos.x = boxDimensions.x - smoothingRadius;
        vel.x *= damping;
    }

    if (pos.y - smoothingRadius < 0)
    {
        pos.y = smoothingRadius;
        vel.y *= damping;
    }
    else if (pos.y + smoothingRadius > boxDimensions.y)
    {
        pos.y = boxDimensions.y - smoothingRadius;
        vel.y *= damping;
    }

    if (pos.z - smoothingRadius < 0)
    {
        pos.z = smoothingRadius;
        vel.z *= damping;
    }
    else if (pos.z + smoothingRadius > boxDimensions.z) {
        pos.z = boxDimensions.z - smoothingRadius;
        vel.z *= damping;
    }

    _particles[id.x].velocity = vel;
    _particles[id.x].position = pos;
}